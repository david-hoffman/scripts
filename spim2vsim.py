#!/usr/bin/env python
# -*- coding: utf-8 -*-
# spim2vsim.py
"""
Convert SPIM data to VSIM data

Copyright (c) 2018, David Hoffman
"""
import os
import glob
import re
import numpy as np
import skimage.external.tifffile as tif
# import our ability to read and write MRC files
import Mrc
import warnings

# import click to run as script
import click
import logging

def rearrange_spim_data(data, dz=1):
    """Assumes data with 4 dimensions

    SPIM takes three different TIFF stacks, one for each orientaion
    Each TIFF stack is arranged as z then phases in the 3rd dimension
    
    Parameters
    ----------
    data : ndarray (4 dim)
        The already loaded SIM data generated by SPIM
    dz : numeric
        the z-step
    """
    # number of phases is hard coded for 3D-SIM
    num_phases = 5
    # data is o, z and p, y, x
    o, zp, y, x = data.shape
    # reshape so it is o, z, p, y, x
    data.shape = o, -1, num_phases, y, x
    # rearrange so now its z, o, p, y, x
    data = np.rollaxis(data, 1)
    # does z need to be flipped?
    if dz > 0:
        # acquired data is in reverse of PSFs
        s = slice(None, None, -1)
    else:
        s = slice(None)
    # flip z, collapse the z, o, p dimensions and return
    return data[s].reshape(-1, y, x)


def get_center_wavlength(emission_filter):
    razor_edge_wl_re = re.compile(r"(\d+)(?=(?:\s*nm)?(?:\s*)?Razor Edge)")
    band_pass_re = re.compile(r"(\d+)\/(\d+)")
    short_pass_re = re.compile(r"(\d+)(?:\s*nm\s*)")
    
    razor_edge = razor_edge_wl_re.findall(emission_filter)
    band_pass = band_pass_re.findall(emission_filter)
    short_pass = short_pass_re.findall(emission_filter)
    
    try:
        short_side = int(razor_edge[0])
    except IndexError:
        short_side = np.nan
        
    try:
        bandcenter, bandwidth = np.array(band_pass[0], float)
    except IndexError:
        bandcenter, bandwidth = np.nan, np.nan
    
    band_short = bandcenter - bandwidth / 2
    band_long = bandcenter + bandwidth / 2
    
    try:
        long_side = int(short_pass[0])
    except IndexError:
        long_side = np.nan
        
    short_side = np.nanmin((short_side, band_short))
    long_side = np.nanmin((long_side, band_long))
    
    return np.nanmean((short_side, long_side))


def parse_settings(path):
    re_dz = re.compile(r"(?:Z Obj Offset\D*\d[^-\d]*)((?:\s*-?\d+(?:\.\d+)?)+)")
    re_dz = re.compile(r"Z Obj Offset.*")
    re_wl = re.compile(r"Excitation Filter.*")

    with open(path) as f:
        buffer = f.readlines()
        dz_str = re_dz.findall("\n".join(buffer))
        wl_str = re_wl.findall("\n".join(buffer))

    _, z0, dz, nz = dz_str[0].split("\t")

    _, emission_filter, laser, power, exposure = wl_str[0].split("\t")
    emission_filter, laser, power, exposure
    cwl = get_center_wavlength(emission_filter)

    return dict(z0=float(z0), dz=float(dz), nz=int(nz), exposure=float(exposure),
                power=float(power), laser=int(laser), center_wl=cwl)


def save_mrc(path, data, wl, dz, dr=0.13, **kwargs):
    header = Mrc.makeHdrArray()
    # initialize it
    # set type and shape
    Mrc.init_simple(header, 4, data.shape)
    # set wavelength in nm
    header.wave = wl
    # set number of wavelengths
    header.NumWaves = 1
    # set dimensions
    header.d = dr, dr, dz
    Mrc.save(data, path, hdr=header, ifExists='overwrite', **kwargs)


def spim2vsim(path_or_basename):
    """Given the path or basename convert data"""
    logging.info("Converting files in {}".format(path_or_basename))
    # num orientations is hard coded to 3
    num_orientations = 3
    # read settings file
    # case for path
    if os.path.isdir(path_or_basename):
        # make sure path has final directory bit
        basename = os.path.join(path_or_basename, "")
        glob_str = basename + "RAW*_ch*.tif"
        # we assume there's only one settings file in the path
        settings_files = glob.glob(os.path.join(path_or_basename, "*_Settings.txt"))
        logging.debug("Found these settings files {}".format(settings_files))
        assert len(settings_files) == 1, "There were {} settings files, please check names".format(len(settings_files))
        settings = parse_settings(settings_files[0])
        # change base name to better suit naming
        basename += os.path.dirname(basename)
    else:
        # case for basename
        basename = path_or_basename
        head, tail = os.path.split(basename)
        glob_str = os.path.join(head, "RAW" + tail + "_ch*.tif")
        settings = parse_settings(path_or_basename + "_Settings.txt")
    logging.debug("Basename is now {}".format(basename))
    # load data
    with warnings.catch_warnings():
        warnings.simplefilter("ignore")
        data = np.array([tif.imread(path) for path in glob.glob(glob_str)])
    logging.debug("data shape is {}".format(data.shape))
    # determine if data is with or without activation
    num_channels = data.shape[0]
    # we assume only three orientaions
    # at most each channel has one activation channel two
    assert num_channels % num_orientations == 0 and num_channels // num_orientations < 3, "data shape = {} doesn't make sense".format(data.shape)
    if num_channels // num_orientations > 1:
        # there was activation performed
        logging.info("Activation was used in this run")
        activation = data[1::2]
        data = data[::2]
        # save activation data
        tif.imsave(basename + "activation.tif", rearrange_spim_data(activation, settings["dz"]))
    vsim_data = rearrange_spim_data(data, settings["dz"])
    # rearrange data
    # save activation data as tif if it exists
    # save mrc
    logging.info("Data saving ...")
    save_mrc(basename + ".mrc", vsim_data, settings["center_wl"], abs(settings["dz"]))
    logging.info("done with {}".format(path_or_basename))

@click.command()
@click.option('--path', '-p', multiple=True, type=click.Path(), help='Top level directory or basename')
@click.option('-v', '--verbose', count=True, default=0)
def main(path, verbose):
    """Convert SPIM SIM data to VSIM like .mrc files for processing"""
    # set output verbosity
    vdict = {0: logging.WARNING, 1: logging.INFO, 2: logging.DEBUG}
    logging.basicConfig(level=vdict[verbose])
    for p in path:
        spim2vsim(p)

if __name__ == '__main__':
    main()
